# Interview Prep - Data Structures and Algorithms

## Understand the Problem
1. Can I restate the problem in my own words?
2. What are the inputs that go into the problem? data types?
3. What are the outputs that should come from the solution? data types?
4. Can the outputs be determined from the inputs? In other words, do the inputs fully determine the outputs? Do you have enough information to solve the problem?
5. How should I label important pieces of data that are a part of the problem?

## Explore Concrete Examples
Features:
User Stories - User Action -> Expected Output
Unit Test - Input -> Expected Output

* Start out with simple examples
* Progress to more complex examples
* Explore with empty inputs
* Explore with invalid inputs

## Break it Down
Write out the steps you need to take (pseudo code)

## Solve/Simplify
If we can solve the problem, solve a simpler problem. Ignore the part thats giving you a hard time, and focus on the parts that are easy to solve. (make any progress to showcase your problem solving skills, which is much better than showing you're stuck and not making any progress)

If you truly don't know, don't be afraid to ask questions on how you would solve it to your interviewer, because at least you are solving your problem solving skills. 

## Look Back and Refactor
When you have the finished code, try to keep the code DRY and refactor it.

Can you check the result?
Can you derive the result differently?
Can you understand it at a glance?
Can you use the result or method for some other problem?
Can you improve the performance of your solution?
Can you think of other ways to refactor the codE?
How have other people solved this problem?

Might be a good idea to also ask the interview how they would go about solving the problem.


ðŸ”¹ If you're preparing for web dev interviews (junior/mid-level), focus on:

Naive String Search (brute-force approach)
Multiple Pointers (like your solution)
KMP Algorithm (only if you want to go deeper)
ðŸ”¹ If you're aiming for Big Tech (FAANG), Competitive Programming, or Backend-heavy roles, then:

Learn KMP for O(n) guaranteed search
Learn Rabin-Karp for hashing-based search
Learn Trie for O(1) guaranteed search
Learn Aho-Corasick for O(1) guaranteed search

